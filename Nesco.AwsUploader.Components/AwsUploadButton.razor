@using System.Net.Http.Headers
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@inject HttpClient Http
@inject ILogger<AwsUploadButton> Logger
@inject IJSRuntime JSRuntime

<button class="btn @ButtonClass" @onclick="TriggerFileSelect" disabled="@(_isUploading || Disabled)">
    @if (_isUploading)
    {
        <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
        <span>@UploadingText</span>
    }
    else
    {
        <span>@ButtonText</span>
    }
</button>

<InputFile OnChange="HandleFileSelected"
           style="display: none;"
           id="@_fileInputId"
           accept="@Accept"
           multiple="@AllowMultiple" />

@code {
    private readonly string _fileInputId = $"fileInput-{Guid.NewGuid():N}";
    private IBrowserFile? _selectedFile;
    private bool _isUploading = false;

    /// <summary>
    /// Upload version to use (ServerUpload or DirectUpload)
    /// </summary>
    [Parameter]
    public UploadVersion Version { get; set; } = UploadVersion.ServerUpload;

    /// <summary>
    /// Button text
    /// </summary>
    [Parameter]
    public string ButtonText { get; set; } = "Upload File";

    /// <summary>
    /// Text to show while uploading
    /// </summary>
    [Parameter]
    public string UploadingText { get; set; } = "Uploading...";

    /// <summary>
    /// Button CSS class
    /// </summary>
    [Parameter]
    public string ButtonClass { get; set; } = "btn-primary";

    /// <summary>
    /// Disable the button
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; } = false;

    /// <summary>
    /// File type filter (e.g., "image/*", ".pdf,.doc")
    /// </summary>
    [Parameter]
    public string? Accept { get; set; }

    /// <summary>
    /// Allow multiple file selection
    /// </summary>
    [Parameter]
    public bool AllowMultiple { get; set; } = false;

    /// <summary>
    /// Maximum file size in bytes (default: 5MB)
    /// </summary>
    [Parameter]
    public long MaxFileSize { get; set; } = 5242880; // 5MB

    /// <summary>
    /// Minimum file size in bytes (default: 0 - no minimum)
    /// </summary>
    [Parameter]
    public long MinFileSize { get; set; } = 0;

    /// <summary>
    /// Allowed file extensions (e.g., new[] { ".pdf", ".jpg", ".png" }). Leave null for no restriction.
    /// </summary>
    [Parameter]
    public string[]? AllowedExtensions { get; set; }

    /// <summary>
    /// Maximum number of files when AllowMultiple is true (default: 10)
    /// </summary>
    [Parameter]
    public int MaxFiles { get; set; } = 10;

    /// <summary>
    /// API endpoint for server upload (default: /api/aws-upload/server)
    /// </summary>
    [Parameter]
    public string ServerUploadEndpoint { get; set; } = "/api/aws-upload/server";

    /// <summary>
    /// API endpoint for presigned URL (default: /api/aws-upload/presigned-url)
    /// </summary>
    [Parameter]
    public string PresignedUrlEndpoint { get; set; } = "/api/aws-upload/presigned-url";

    /// <summary>
    /// Optional folder path in S3 (e.g., "documents/invoices")
    /// </summary>
    [Parameter]
    public string? Folder { get; set; }

    /// <summary>
    /// Optional custom filename to use instead of original
    /// </summary>
    [Parameter]
    public string? CustomFileName { get; set; }

    /// <summary>
    /// If true, preserve original filename; if false, generate GUID filename (default: true)
    /// </summary>
    [Parameter]
    public bool PreserveFilename { get; set; } = true;

    /// <summary>
    /// Callback when upload completes successfully
    /// </summary>
    [Parameter]
    public EventCallback<UploadResult> OnUploadComplete { get; set; }

    /// <summary>
    /// Callback when upload fails
    /// </summary>
    [Parameter]
    public EventCallback<UploadErrorResult> OnUploadError { get; set; }

    /// <summary>
    /// Callback when upload starts
    /// </summary>
    [Parameter]
    public EventCallback OnUploadStart { get; set; }

    /// <summary>
    /// Callback when file is selected
    /// </summary>
    [Parameter]
    public EventCallback<IBrowserFile> OnFileSelected { get; set; }

    private async Task TriggerFileSelect()
    {
        // Trigger click on the hidden file input using JavaScript
        await JSRuntime.InvokeVoidAsync("eval", $"document.getElementById('{_fileInputId}').click()");
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        _selectedFile = e.File;

        // Validate file before proceeding
        var validationError = ValidateFile(_selectedFile);
        if (!string.IsNullOrEmpty(validationError))
        {
            if (OnUploadError.HasDelegate)
            {
                await OnUploadError.InvokeAsync(new UploadErrorResult
                {
                    ErrorMessage = validationError,
                    FileName = _selectedFile.Name
                });
            }
            _selectedFile = null;
            return;
        }

        if (OnFileSelected.HasDelegate)
        {
            await OnFileSelected.InvokeAsync(_selectedFile);
        }

        // Automatically start upload after file selection
        await UploadFile();
    }

    private string? ValidateFile(IBrowserFile file)
    {
        // Check file size
        if (file.Size > MaxFileSize)
        {
            return $"File size ({file.Size / 1024.0 / 1024.0:F2} MB) exceeds maximum allowed size ({MaxFileSize / 1024.0 / 1024.0:F2} MB)";
        }

        if (file.Size < MinFileSize)
        {
            return $"File size ({file.Size / 1024.0 / 1024.0:F2} MB) is below minimum required size ({MinFileSize / 1024.0 / 1024.0:F2} MB)";
        }

        // Check file extension
        if (AllowedExtensions != null && AllowedExtensions.Length > 0)
        {
            var extension = Path.GetExtension(file.Name).ToLowerInvariant();
            if (!AllowedExtensions.Any(ext => ext.ToLowerInvariant() == extension))
            {
                return $"File type '{extension}' is not allowed. Allowed types: {string.Join(", ", AllowedExtensions)}";
            }
        }

        return null;
    }

    private async Task UploadFile()
    {
        if (_selectedFile == null) return;

        _isUploading = true;

        if (OnUploadStart.HasDelegate)
        {
            await OnUploadStart.InvokeAsync();
        }

        try
        {
            if (Version == UploadVersion.ServerUpload)
            {
                await UploadViaServer();
            }
            else
            {
                await UploadViaPresignedUrl();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Upload error");

            if (OnUploadError.HasDelegate)
            {
                await OnUploadError.InvokeAsync(new UploadErrorResult
                {
                    ErrorMessage = ex.Message,
                    Exception = ex,
                    FileName = _selectedFile.Name
                });
            }
        }
        finally
        {
            _isUploading = false;
            _selectedFile = null;
        }
    }

    private async Task UploadViaServer()
    {
        using var content = new MultipartFormDataContent();
        var fileContent = new StreamContent(_selectedFile!.OpenReadStream(maxAllowedSize: MaxFileSize));
        var contentType = string.IsNullOrEmpty(_selectedFile.ContentType) ? "application/octet-stream" : _selectedFile.ContentType;
        fileContent.Headers.ContentType = new MediaTypeHeaderValue(contentType);

        content.Add(fileContent, "file", _selectedFile.Name);

        // Add folder, customFileName, and preserveFilename parameters
        if (!string.IsNullOrEmpty(Folder))
        {
            content.Add(new StringContent(Folder), "folder");
        }
        if (!string.IsNullOrEmpty(CustomFileName))
        {
            content.Add(new StringContent(CustomFileName), "customFileName");
        }
        content.Add(new StringContent(PreserveFilename.ToString()), "preserveFilename");

        var response = await Http.PostAsync(ServerUploadEndpoint, content);
        var result = await response.Content.ReadFromJsonAsync<UploadResponse>();

        if (response.IsSuccessStatusCode && result != null)
        {
            if (OnUploadComplete.HasDelegate)
            {
                await OnUploadComplete.InvokeAsync(new UploadResult
                {
                    Url = result.Url!,
                    Message = result.Message!,
                    FileName = _selectedFile.Name,
                    UploadMethod = UploadVersion.ServerUpload
                });
            }
        }
        else
        {
            if (OnUploadError.HasDelegate)
            {
                await OnUploadError.InvokeAsync(new UploadErrorResult
                {
                    ErrorMessage = result?.Error ?? "Upload failed",
                    FileName = _selectedFile.Name,
                    StatusCode = (int)response.StatusCode
                });
            }
        }
    }

    private async Task UploadViaPresignedUrl()
    {
        var contentType = string.IsNullOrEmpty(_selectedFile!.ContentType) ? "application/octet-stream" : _selectedFile.ContentType;

        // Step 1: Get presigned URL from server
        var presignedRequest = new
        {
            FileName = _selectedFile.Name,
            ContentType = contentType,
            Folder = Folder,
            CustomFileName = CustomFileName,
            PreserveFilename = (bool?)PreserveFilename
        };
        var response = await Http.PostAsJsonAsync(PresignedUrlEndpoint, presignedRequest);
        var result = await response.Content.ReadFromJsonAsync<PresignedUrlResponse>();

        if (!response.IsSuccessStatusCode || result == null)
        {
            if (OnUploadError.HasDelegate)
            {
                await OnUploadError.InvokeAsync(new UploadErrorResult
                {
                    ErrorMessage = result?.Error ?? "Failed to get presigned URL",
                    FileName = _selectedFile.Name,
                    StatusCode = (int)response.StatusCode
                });
            }
            return;
        }

        // Step 2: Upload directly to S3 using presigned URL
        // Note: S3 presigned URLs don't support chunked transfer encoding,
        // so we need to read the file into memory first
        using var httpClient = new HttpClient();
        using var fileStream = _selectedFile.OpenReadStream(maxAllowedSize: MaxFileSize);
        using var memoryStream = new MemoryStream();
        await fileStream.CopyToAsync(memoryStream);
        memoryStream.Position = 0;

        var streamContent = new StreamContent(memoryStream);
        streamContent.Headers.ContentType = new MediaTypeHeaderValue(contentType);
        streamContent.Headers.ContentLength = memoryStream.Length;

        var uploadResponse = await httpClient.PutAsync(result.PresignedUrl, streamContent);

        if (uploadResponse.IsSuccessStatusCode)
        {
            var publicUrl = result.PublicUrl ?? result.PresignedUrl!.Split('?')[0];

            if (OnUploadComplete.HasDelegate)
            {
                await OnUploadComplete.InvokeAsync(new UploadResult
                {
                    Url = publicUrl,
                    Message = "File uploaded successfully",
                    FileName = _selectedFile.Name,
                    UploadMethod = UploadVersion.DirectUpload,
                    S3Key = result.Key
                });
            }
        }
        else
        {
            var errorContent = await uploadResponse.Content.ReadAsStringAsync();

            if (OnUploadError.HasDelegate)
            {
                await OnUploadError.InvokeAsync(new UploadErrorResult
                {
                    ErrorMessage = $"Failed to upload to S3. Status: {uploadResponse.StatusCode}. Error: {errorContent}",
                    FileName = _selectedFile.Name,
                    StatusCode = (int)uploadResponse.StatusCode
                });
            }
        }
    }

    private class UploadResponse
    {
        public string? Url { get; set; }
        public string? Message { get; set; }
        public string? Error { get; set; }
    }

    private class PresignedUrlResponse
    {
        public string? PresignedUrl { get; set; }
        public string? Key { get; set; }
        public string? PublicUrl { get; set; }
        public string? Message { get; set; }
        public string? Error { get; set; }
    }

    public enum UploadVersion
    {
        ServerUpload = 1,
        DirectUpload = 2
    }

    public class UploadResult
    {
        public string Url { get; set; } = string.Empty;
        public string Message { get; set; } = string.Empty;
        public string FileName { get; set; } = string.Empty;
        public UploadVersion UploadMethod { get; set; }
        public string? S3Key { get; set; }
    }

    public class UploadErrorResult
    {
        public string ErrorMessage { get; set; } = string.Empty;
        public string FileName { get; set; } = string.Empty;
        public int? StatusCode { get; set; }
        public Exception? Exception { get; set; }
    }
}
